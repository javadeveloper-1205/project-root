### Подготовка базового окружения

Прежде чем писать игры, нам нужно настроить проект, научиться подключать к нему внешние библиотеки и делать его публичным (при помощи сервиса jitpack.io). Настройка окружения достаточно объёмна, поэтому мы разобьём её на несколько шагов:

   * Вначале просто напишем HelloWorld и добьёмся, чтобы он у нас заработал
   * На следующем шаге автоматизируем сборку проекта с помощью **Maven** и добавим зависимости от внешних библиотек
   * Затем добавим необходимые в современных Java-проектах инструменты и библиотеки

И после этого уже приступим к реализации основной части — написанию логики игр.

### В какой IDE делать?

По поводу IDE — на этой стадии вы можете использовать любую IDE, но рекомендуется [IntelliJ IDEA](https://www.jetbrains.com/idea/download/) (бесплатная IDEA Community Edition для данного проекта вполне подойдёт). Версию можно выбрать стабильную, а можно EAP — она достаточно стабильна и существенно на ход проекта это не повлияет, зато в ней можно найти некоторые удобные фичи, которых пока ещё нет в стабильной версии.

### Как выполнять задание?

Начнём с малого — напишем `Hello World!` и убедимся, что всё работает, а потом будем добавлять необходимую обвеску.

#### Создаём файловую структуру приложения

Создайте директорию, в которой будет располагаться наш проект. В дальнейшем на неё мы будем ссылаться как на `{project-root}`, **корневой каталог проекта** или просто **корень проекта** — всё это синонимы.

Кроме того, корневой каталог проекта по принятой в Java-мире конвенции должен называться так же, как называется проект. В дальнейшем мы будем ссылаться на его имя как на `{project-name}`.

В корне проекта нужно создать каталоги, в которых Maven (работать с ним начнём на следующем шаге) будет искать исходные коды, собирая из них наш проект. Стандартная для Java-проектов структура каталогов выглядит так:

     {project-root}
       - src
         - main
           - java

В разных проектах могут быть дополнительные к этой структуре каталоги, но сейчас нам достаточно приведённой выше структуры.

В каталоге `java` (путь `{project-root}/src/main/java`) будут располагаться файлы c java-кодом. Если Вы используете IntelliJ IDEA, то это означает, что эта директория должна быть подсвечена синим цветом - тогда IDEA будет ориентироваться на то, что это - не просто директория, а директория с исходными кодами.

_Если по какой-то причине эта папка воспринимается IDEA'ей как обычная папка и подсвечивается обычным жёлтым цветом, следует щёлкнуть на ней правой кнопкой мыши и выбрать в выпадающем меню пункт "Mark Directory as" -> "Sources root"_

В java принято группировать код в [пакеты](https://ru.wikipedia.org/wiki/Package_(Java)). Поэтому создайте пакет (то есть, опять же, каталог) в директории `java` и назовите его `games` — ведь мы будем делать игры.

#### Пишем код

Забегая немного вперёд, скажем, что нашей первой игрой будет **Slot** — программная реализация автоматов "однорукий бандит". 
Поэтому в пакете `games` создайте файл класса `Slot.java` и добавьте в него следующий код:
```java
package games;

public class Slot {

    public static void main(String... __) {
        System.out.println("Hello, World!");
    }
}
```

Имя пакета, указанное в директиве `package`, должно совпадать с именем подкаталога внутри каталога `java`. А точнее с именем 
каталога, в котором находится файл с классом — это имя `games`. 
Пакеты в Java решают проблему **конфликта имён** — ситуации, когда несколько классов имеют одинаковые имена.
В этом случае их различают по так называемым полным (full) именам, которые складываются из имени пакета и имени 
класса: `packageName.className`. В примере выше полное имя класса — `games.Slot`. Полное имя класса всегда должно быть уникальным.

При создании классов необходимо придерживаться простого правила: в файле может быть только один публичный 
(ещё называют — "открытый") класс и имя этого класса должно совпадать с именем файла. 
При определении открытого класса используется ключевое слово `public`. 
Именно поэтому мы создали файл `Slot.java` и поместили в него публичный класс `Slot`.

#### Компилируем

Java — компилируемый язык. Соответственно, перед выполнением надо откомпилировать наш java-класс. 
Это делается при помощи стандартной Java утилиты `javac`, входящей в поставку JDK. 
Кстати, название `javac` —  сокращение от **java c**ompiler.

В результате компиляции получится [байт-код](https://ru.wikipedia.org/wiki/%D0%91%D0%B0%D0%B9%D1%82-%D0%BA%D0%BE%D0%B4_Java). 
Его, как и исходный код (файлы на языке java), надо где-то хранить. Создадим для этого специальные каталоги. 
Структура каталогов будет такой:

     {project-root}
       - target
         - classes

Теперь всё подготовлено для компиляции! Чтобы откомпилировать программу, выполните в терминале команду из корня проекта:

     $ javac -d ./target/classes ./src/main/java/games/Slot.java

Или в Windows:

     $ javac -d target/classes src/main/java/games/Slot.java

С помощью ключа `-d` указываем директорию, куда нужно поместить откомпилированные файлы — `./target/classes`. 
Последним аргументом указываем, что компилировать — `./src/main/java/games/Slot.java`.

В результате компиляции у нас должен появиться файл `{project-root}/target/classes/games/Slot.class`. 
Проверьте, что он действительно появился. 
Открывать его не надо — это файл байт-кода, для его анализа необходимы специальные утилиты 
(например, входящая в стандартную поставку Java утилита **javap**). 
А если открыть его обычным редактором как текстовый файл, то увидите полнейшую абракадабру. 
Этот формат предназначен не для человека, а для виртуальной Java-машины (JVM).

#### Запускаем

Чтобы запустить нашу программу, выполним в коммандной строке:

     $ java -cp ./target/classes games.Slot

Или в Windows:

     $ java -cp ./target/classes games.Slot

В результате должна появиться надпись - "Hello, World!". Поздравляем! Вы написали, скомпилировали и 
выполнили свою первую Java-программу!

### Автоматизируем набор команд при помощи утилиты Make

Использование командной строки требует запоминания достаточно большого количества команд, 
их опций и особенностей использования. 
Поэтому, когда инструментов много, обычно хочется абстрагироваться от них, 
разработать свой собственный набор простых команд и использовать их.

Эффективный способ для этого — утилита командной строки [Make](https://youtu.be/pK9mF5aK05Q). 
Вы наверняка слышали, что она служит для сборки проектов на С и С++. Но она может быть применена и для простого сокрытия 
сложностей команд — что мы и собираемся сделать.

Создайте в корне проекта файл с именем Makefile и пропишите туда уже использованные нами команды:
```makefile
compile:
	javac -d ./target/classes ./src/main/java/games/Slot.java

run:
	java -cp ./target/classes games.Slot
```

_Помните, что для отступов здесь нужно пользоваться исключительно **символами табуляции**, а не пробелами_

Теперь для запуска можно вместо набора столь длинной команды, какую мы набирали ранее, просто написать:

    $ make run

И Вы также увидите строчку вывода программы - "Hello, World!".

Что касается компиляции, то нужно будет сначала избавиться от результатов 
предыдущей компиляции, удалив файл `./target/classes/games/Slot.class`. После этого можно будет выполнить:

    $ rm ./target/classes/games/Slot.class
    $ make compile run

#### Автоматизируем очистку директории от результатов предыдущей сборки

Удаление файлов перед компиляцией тоже придётся делать постоянно, после каждого изменения исходного кода. 
Так что давайте добавим его в наш Makefile и назовём `clean`. Это действие удаляет каталог с результатами сборки:
```makefile
clean:
	rm -rf ./target
```

Осталось поправить действие `compile`. Теперь, прежде чем выполняться, оно должно выполнять действие `clean` 
(в таких случаях говорят, что `compile` зависит от `clean`). 
Также оно будет создавать заново необходимые для компиляции файлов каталоги 
(утилита `javac` создаёт каталоги только для пакетов Java).
```makefile
compile: clean
	mkdir -p ./target/classes
	javac -d ./target/classes ./src/main/java/games/Slot.java
```

Теперь введите команду и проверьте, что по-прежнему получаете корректный результат:

    $ make compile run

#### Устанавливаем действие по умолчанию

Один из величайших принципов современного дизайна языков программирования, библиотек и фреймворков, 
с которыми вы часто будете сталкиваться по мере обучения программированию, звучит как "Convention over configuration". 
Его смысл состоит в том, что по умолчанию система должна вести себя так, как в наиболее типичном случае от неё и требуется. 
Это позволяет вносить в систему гибкость, сохраняя лаконичность кодовой базы.

В нашем случае разумно было бы ожидать, что любой, кто выкачал наш проект, захочет сделать при помощи make именно то, 
что мы только что делали — выполнить команды `compile` и `run`. Так что согласно принципу "Convention over configuration" 
нужно сделать для make такое поведение **поведением по умолчанию**.

В Makefile это реализуется при помощи указания значения специальной переменной `.DEFAULT_GOAL`. 
Ей можно присвоить имя команды — и эта команда будет выполняться по умолчанию (просто по команде `make` без параметров).

Правда, есть ограничение — такая команда должна быть только одна, так что не получится прописать в неё `compile run`. 
Поэтому придётся сделать ещё одну команду, которая бы зависела от компиляции и запуска. Назвать её лучше всего `compile-run`:
```makefile
compile-run: compile run
```

Теперь можно прописать действие по умолчанию. И лучше сделать это в начале файла, чтобы сразу было видно, 
**что** выполняется по умолчанию:
```makefile
.DEFAULT_GOAL := compile-run
```

В результате в командной строке можно просто набрать:
```sh
$ make
```

и наслаждаться результатом!

Теперь осталось только за-.gitignore'ть каталог `target` со всем его содержимым и...

Поздравляем! Вы закончили первый шаг. Не забудьте сделать commit и push в GitHub.

Переходите ко второму шагу, впереди ещё много интересного :)
