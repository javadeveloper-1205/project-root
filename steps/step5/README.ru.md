# Шаг №5 - Вторая игра - "Пьяница"

## Для чего выполнять это задание

Задание спроектировано для Вашей тренировки в процедурном программировании. Те из Вас, кто считает, что владеет программированием в ООП и функциональном стиле, потерпите и постарайтесь себя сдерживать - задание достаточно простое, чтобы можно было обойтись без этого и решить задачу, сосредоточившись исключительно на операторах, статических (`static`) методах, статических полях (т.е. переменными в "глобальном scope") и примитивных типах c `enum`'ами. При этом понадобится всего 2 класса.

Не переживайте - ООП у нас начнётся со следующего проекта, а функциональный подход будет возможность попрактиковать, начиная с третьего проекта.

## Что должно получиться

Нужно написать [карточную игру "Пьяница"](https://ru.wikipedia.org/wiki/Пьяница_(карточная_игра)), вариант правил ["Шестерку бьёт не всё"](https://ru.wikipedia.org/wiki/Пьяница_(карточная_игра)#Шестерку_бьёт_не_всё) колодой из 36 карт.

## Как выполнять задание

Для данного проекта нам в минимальном объёме понадобится процедурное программирование - т.е. здесь уже не достаточно будет написать код в методе `public static void main()` класса, а понадобится создавать и другие методы. Не бойтесь - Объектно-Ориентированного Программирования не будет - вся задача будет реализована в рамках одного класса и методы все будут статические (все с модификаторами `static` - как и у `main`'а), но их всё же будет несколько.

### Выбор игры

Однако для начала нам необходимо реализовать для пользователя выбор между играми, ведь пока у нас была лишь одна игра мы без вопросов запускали её, но теперь у нас будет две игры и у пользователя нужно будет спросить - в какую именно игру он хочет сыграть?

Создайте класс `Choice` в отдельном файле `Choice.java` в той же папке, что и `Slot.java`. Вставьте в него следующее описание entrypont'а:  
```java
System.out.println("Выберите игру:\n1 - \"однорукий бандит\", 2 - \"пьяница\"");
switch (System.in.read()) {
  case '1': Slot.main(); break;
  case '2': Drunkard.main(); break;
  default: System.out.println("Игры с таким номером нет!");
}
```  
Надеемся, здесь всё понятно - мы сначала выводим пользователю предложение выбрать игру, а потом, если он нажмёт 1 - запускаем уже написанного нами "Однорукого бандита", 2 - ещё не написанную нами игру "Пьяница", всё остальное будет выдавать ошибку.

Для того, чтобы этот код скомпилировался, нам нужно создать "заглушку" - класс `Drunkard` c пока пустой (нужно пока так же, как в первом шаге, написать `Hello, World`)

Теперь нужно перенастроить entrypoint в Maven'е на класс `Choice`. Напомним, что делается это в теге `mainClass` плагина `maven-assembly-plugin`.

Соберите, запустите, убедитесь, что выбор работает и закоммитте изменения.

### Типы данных для карточных игр

В отличие от прошлой игры, где мы оперировали лишь числами, здесь и в следующей игре мы будем манипулировать картами, у которых есть не только числовая характеристика, но и масть. Поэтому, чтобы не запутаться, нам нужна будет система типов, которая позволит удобно представлять каждую карту. Это будет удобно при написании и при выводе информации на консоль.

Т.к. карт у нас 36, давайте договоримся представлять их числами по порядку. Всего у нас по 9 карт каждой масти, соответственно представляя карты в виде числа, при переходе через значение 8 мы меняем масть.

Т.е. картина примерно такая:  
   * 0 - 6'ка  
   * 1 - 7'ка  
   * 2 - 8'ка  
   * 3 - 9'ка  
   * 4 - 10'ка  
   * 5 - Валет  
   * 6 - Дама  
   * 7 - Король  
   * 8 - Туз  
   * дальше - 6'ка другой масти - и т.д.  


#### Масть (suit)

Проще всего представить это типами-перечислениями. Введём два типа. Один - для масти:
```java
enum Suit {
  SPADES, // пики
  HEARTS, // червы
  CLUBS, // трефы
  DIAMONDS // бубны
}
```

Можно, но не обязательно помещать его пока в отдельный файл - можно сделать внутренним перечислимым типом внутри класса `Drunkard`, разместив его сразу после метода `main`.

Чтобы получать его из числа, давайте напишем статический метод, который будет выглядеть примерно так:
```java
private static Suit getSuit(int cardNumber) {
  return Suit.values()[cardNumber / 9];
}
```

Здесь используется ряд особенностей языка Java:  
   * Каждый перечислимый тип - это на самом деле класс-наследник от специального класса Enum, в котором в частности определён метод values(), возвращающий перечислимые значения в качестве массива, причём _в порядке следования в описании_, т.е. вначале будут пики, потом червы, потом трефы и последними - бубны.  
   * Обращение к элементам массива происходит при помощи квадратных скобок, в которых указывается индекс элемента - он и возвращается. Причём важно не забывать о том, что минимальное значение индекса - `0`, а вовсе не `1`   
   * Деление целых чисел всегда возвращает целый результат, при этом не происходит округления, а происходит просто отбрасывание остатка от деления, т.е. даже результат `8 / 9` это `0`. Если же нам нужно получить дробный результат - то один из операндов должен быть дробным числом, например `8 / 9.0` это `0.8888888888888888`, но нам здесь нужно именно такое деление нацело, ведь мы по этому индексу получаем элемент массива.  

Чтобы проверить, корректно ли работает код, вызовите эту функцию, передав, например, максимально-возможное значение - `35` (мы договорились, что карт будет `36`, но т.к. нумерацию начинаем с `0`'я, то максимальное значение индекса будет `35`):  
```java
System.out.println("Масть 36-й карты - " + getSuit(35));
```

Соберите, запустите, убедитесь, что при выборе игры "Пьяница" на консоль выведется надпись:
 
     Масть 36-й карты - DIAMONDS

#### Размерность (par)

Похожая история и с размерностью:
```java
enum Par {
  SIX,
  SEVEN,
  EIGHT,
  NINE,
  TEN,
  JACK, // Валет
  QUEEN, // Дама
  KING, // Король
  ACE // Туз
}

private static Par getPar(int cardNumber) {
  return Par.values()[cardNumber % 9];
}
```

Здесь мы используем уже знакомый нам по предыдущему шагу оператор возврата остатка от деления н**а**цело - `%`.

Чтобы проверить, корректно ли работает код, вызовите функцию `getPar`, передав ей максимально-возможное значение:
```java
System.out.println("Размерность 36-й карты - " + getPar(35));
```

Соберите, запустите, убедитесь, что при выборе игры "Пьяница" на консоль выведется надпись:

    Размерность 36-й карты - ACE

#### Вся информация по карте

Напишем удобный метод, который бы возвращал всю информацию о карте - т.е. её масть, потом пробел и размерность:
```java
private static String toString(int cardNumber) {
  return getPar(cardNumber) + " " + getSuit(cardNumber);
}
```

Убедитесь, что при вызове `toString(35)` на консоль выведется надпись:
 
     ACE DIAMONDS

Теперь для вывода информации по карте на консоль, достаточно просто дёрнуть эту функцию, передав ей номер карты.

#### Выносим константы

Вы наверняка заметили, что у нас появилось крошечное дублирование кода - число 9 встречается у нас 2 раза - в методах `getPar` и `getSuit`. Возможна ситуация, при которой нам понадобится изменить это число (например, мы захотим изменить наш код, перейдя на 52-карточную колоду), и изменим его в одном месте, но забудем изменить в другом - и получим неправильное поведение.

Стандартный способ избавления от такого рода дублирования заключается в том, чтобы вынести это значение в константу. Пропишите в начале класса:
```java
private static final int PARS_TOTAL_COUNT = 9;
```

И измените теперь в этих двух методах `9`'ки на `PARS_TOTAL_COUNT`.

Правда, мы решили проблему лишь частично, поскольку неявное дублирование кода теперь присутствует ещё и в том, что значение этой константы вычислимо и зависит от кол-ва значений типа `Par`. Было бы здорово получить настолько гибкий код, чтобы для добавления карт нужно было лишь изменить кол-во значений в соответствующих enum'ах.

Поэтому вместо того, чтобы задавать значение напрямую в коде (как говорят в таких случаях, "хардкодить"), давайте опишем формулой вычисление значения этой константы:
```java
private static final int PARS_TOTAL_COUNT = Par.values().length; //9
```

По похожему сценарию давайте заведём константу `CARDS_TOTAL_COUNT` - суммарное кол-во карт - она нам понадобится в дальнейших шагах алгоритма:
```java
private static final int CARDS_TOTAL_COUNT = PARS_TOTAL_COUNT * Suit.values().length; //36
```

#### Колода карт

Вопрос - каково максимальное кол-во карт в колоде?

Если Вы ответили `CARDS_TOTAL_COUNT`, то Вы правы. А вовсе не 36, как может кому-то показаться. Потому что это только пока оно 36, изменим - будет больше, но если изменим - изменится и значение константы, так что лучше исходить из того, что карт в колоде у нас именно `CARDS_TOTAL_COUNT`.

Как представить колоду карт? Очевидно, нам нужен массив, в котором они все будут лежать. Т.к. массивы в Java не могут менять своего размера, нам нужно инициализировать массив, максимальный размер которого, как мы уже выяснили, `CARDS_TOTAL_COUNT`, ведь все карты могут в нём оказаться (это будет означать выигрыш одного и проигрыш остальных игроков).

Учитывая, что количество карт будет то уменьшаться, то увеличиваться, нам нужно в каждый момент времени иметь информацию о том, в каких ячейках лежат карты, а какие - пусты.

С другой стороны, давайте подумаем вот о чём: какие операции мы будем осуществлять над колодами? В игре "Пьяница" операции две - это  
   * извлечение "верхней" карты
   * добавление нескольких карт "вниз" колоды - т.е. с другого конца.

Получается, что нам нужна структура данных, которая носит название "очередь" и реализует принцип Первым вошёл - первым вышел (First In - First Out, FIFO):
!["Last In First Out"](https://im0-tub-ru.yandex.net/i?id=c641f0af22363e31e2fd8b16ac1df6ea-l&n=13 "Last In First Out")  

_В Java Collection Framework\`е есть специальные классы, которые реализуют очереди, но пользование ими требует знания основ ООП, поэтому пока сделаем это вручную._

Колода достаточно объёмна, поэтому перемещать её внутри массива каждый раз будет накладно - лучше попытаться придумать, как реализовать очередь при помощи указателей на ячейки массива. Сделать это будет проще, если мы введём следующие переменные-указатели:  
   * Указатель на ячейку, в которую мы будем добавлять карты (назвать можно `playersCardHead`)
   * Указатель на ячейку в массиве, с которой начинаются карты (назвать можно, например, `playersCardTail`)

_Именование `head` и `tail` (соотв., "голова" и "хвост") принято при работе с очередями и происходит, очевидно, от сравнения очереди со змеёй, которая как бы ползёт, продвигая голову и подтягивая за собой хвост._

Мы будем их передвигать в направлении увеличения индекса, минуя "точку разрыва", т.е. следующая за максимальной будет 0-я позиция. Делать это мы будем с помощью всё того же приёма - после увеличения счётчика на единицу, присваивать ему значение остатка от деления н**а**цело получающегося числа на размер массива - т.е. на константу `CARDS_TOTAL_COUNT`.

Это решает обе проблемы:
   * Чтобы узнать, сколько у человека карт, просто берём разницу этих указателей
      - А если между ними "точка разрыва", прибавляем к указателю `playerCardHead` длину массива и вычитаем `playerCardTail`  
   * Чтобы взять карту сверху колоды,
      - извлекаем её из ячейки с индексом `playerCardTail`,
      - увеличиваем `playerCardTail` на 1
      - присваиваем `playerCardTail` значение, равное остатку его деления на `CARDS_TOTAL_COUNT`, чтобы при достижении максимального значения его значение возвращалось к `0`  
   * Чтобы добавить карты,
      - добавляем каждую из них туда, куда ссылается второй указатель - `playerCardHead`,
      - увеличиваем `playerCardHead` на 1
      - присваиваем `playerCardHead` значение, равное остатку его деления на `CARDS_TOTAL_COUNT`, чтобы при достижении максимального значения его значение возвращалось к `0`

Последние две операции над курсорами во избежание дублирования кода можно вынести в отдельную процедуру, которая возвращала бы следующий индекс, правильно проходя "точку разрыва":
```java
private static int incrementIndex(int i) {
  return (i + 1) % CARDS_TOTAL_COUNT;
}
```

##### Проблема определения выигравшего

В вышепредложенной реализации очереди с двумя счётчиками есть проблема определения выигравшего игрока в конце игры.

Заключается она в том, что без дополнительных ухищрений невозможно отличить ситуацию, когда у игрока не осталось карт (`0`) от ситуации, при которой у игрока все карты (`36`). Поскольку в обоих этих ситуациях оба счётчика будут указывать на одну и ту же ячейку.

Как это получается? Давайте образно представим себе нашу очередь в виде кольца. Где-то у этого кольца "стык", который мы назвали "точкой перехода" - там, где максимальный индекс сменяется на `0`'вой, но это не важно - эту проблему мы уже решили. Счётчики `head` и `tail` бегут по этому кольцу в одном направлении. Счётчик `head` ведёт себя беспорядочно:
   - он то продвигается аж на 2'е позиции (в случае выигрыша игрока),  
   - то изредка продвигается на 1'у позицию (в случае спора - "ничьей"),
   - то не меняется (в случае проигрыша игрока).

При этом счётчик `tail` ведёт себя более стабильно, с каждым раундом планомерно и неуклонно продвигаясь на 1'у позицию вперёд. Можно условно представить, что `head` пытается убежать от `tail`'а, а `tail` его постепенно настигает.

Ситуацию, при которой `tail` настигнет `head`'а мы рассматриваем как проигрыш игрока, ведь это значит, что все его карты - ушли второму игроку. Так что кажется логичным написать такой метод, который бы определял проигрыш, реализовав его примерно так:  
```java
private static boolean playerCardsIsEmpty(int playerIndex) {
  int tail = playerCardTails[playerIndex];
  int head = playerCardHeads[playerIndex];

  return tail == head;
}
```  
Но ситуация может сложиться и по-иному: `head` может уйти по нашему "кольцу" настолько далеко, что настигнет `tail`'а уже с другой стороны (тогда мы получим древний символ "Уроборос" цикличности и бесконечности жизни - змею, кусающую себя за хвост). Это будет соответствовать ситуации, когда игрок выиграет и соберёт всю колоду из ~~36~~ `CARDS_TOTAL_COUNT` карт. Получается, что только что приведённая реализация метода `playerCardsIsEmpty` **и в этом случае выдаст `true`**, из-за чего выигравший игрок будет считаться проигравшим.

Собственно, в данном случае проблема сводится к тому, что эти две ситуации просто нужно различить, чтобы, когда они возникли, понять - какой игрок выиграл, а какой - проиграл.

Тут возможно две основных стратегии решения:
   * Можно решить проблему, что называется, "здесь и сейчас" - на каждой итерации цикла запоминать в булеву переменную - который из игроков в ней выиграл. Тогда после того, как мы вылетим из цикла, зная, что кто-то выиграл, а кто-то проиграл, мы сможем посмотреть, кто выиграл последний раунд - и, естественно, это и окажется наш победитель.
   * Можно решить проблему в общем. Для этого проще всего недопустить ситуации, когда победу невозможно отличить от поражения, при помощи дополнительной "позиции разрыва" - сделать длину нашего "кольца", т.е. массива, на единицу больше, чем максимально-возможное количество карт, которые мы в неё можем поместить. Т.е. в нашем случае не `36`, а `37`. Тогда `tail` по-прежнему сможет догнать `head`, но вот `head` сможет лишь приблизиться к `tail`'у, обойдя кольцо с другой стороны. И тогда вышеприведённая реализация метода `playerCardsIsEmpty` станет адекватной.

Выберите, какая Вам кажется более подходящей, либо придумайте свою.

### Логика игры

Теперь, когда у нас подготовлены все необходимые структуры данных, можем приступать к решению основной задачи в методе `main`.

Итак, алгоритм состоит из 2-х фаз:
   * раздачи карт
   * игры до победного

_Сразу оговоримся - правила таковы, что, хотя вероятность этого достаточно низка, но игра может идти бесконечно, так что может так статься, что прерывать её придётся насильственно - при помощи комбинации клавиш `Ctrl + С`, так что если она у вас "зациклится" - смело прерывайте (как минимум, это произойдёт, если вы раздадите карты одинакового достоинства разных мастей в одинаковом порядке обоим игрокам - у вас будут вечные споры, но возможны и более хитрые комбинации, которые приведут к вечному циклу)._ 

#### Фаза №1: Раздаём карты

Игрока у нас будет 2 и играть они будут между собой. Так что можно завести отдельные два массива, а можно схитрить и сделать массив второго порядка, в котором будет как бы два столбца, соответствующих игрокам и `CARDS_TOTAL_COUNT` линий, соответствующих позициям для карт:
```java
private static int[][] playersCards = new int[2][CARDS_TOTAL_COUNT];
```

Курсоры тоже тогда имеет смысл хранить в массивах, где индексы будут соответствовать номерам игроков:
```java
private static int[] playerCardTails = new int[2];
private static int[] playerCardHeads = new int[2];
```

Итак, как же раздать карты?

Для этого нужно:
   * Создать массив со всеми 36 картами
   * Воспользоваться для него методом shuffle из класса MathArrays (помните, во втором шаге мы специально для этого добавили библиотеку Apache Commons Math)
   * После этого половину карт добавить в колоду первого игрока, а вторую половину - в колоду второго.

Напишите это и выведите на экран, чтобы убедиться, что всё раздалось в случайном порядке и каждый игрок получил по 18 карт.

После того, как убедитесь, сотрите код вывода на экран этой информации - в дальнейшем он будет лишь мешать. 

#### Фаза №2: Игра

Сама игра после таких приготовлений проста и понятна. Она состоит из следующих шагов:
   * Организуем потенциально бесконечный цикл, в котором на каждой итерации проверяем, не пуста ли стопка кард кого-либо из игроков?  
      - Если пуста - выходим из цикла, печатаем номер игрока победителя и завершаем работу программы.  
   * Внутри цикла берём по одной карте у каждого игрока и сравниваем их исключительно по размерности (масть не в счёт)  
      - Напомним, что для этого мы уже написали метод `getPar` выше
      - Также напомним о том, что здесь необхоимо поддержать логикой правило "шестёрку бьют не все", т.е. 6-ка бьёт туза  
   * Если достоинство карты одного игрока больше достоинства карты другого - победил первый и к нему в колоду добавляются обе карты  
   * Если по достоинству карты одинаковые - это спор. Не будем усложнять себе жизнь сложными правилами спора - с залогом и прочим, скажем просто, что при споре все остаются при своих и карты возвращаются в колоды их бывших хозяев.  
   * По итогу итерации выводите кол-во карт у каждого игрока, чтобы можно было ориентироваться.

Реализуйте алгоритм, позапускайте игру и убедитесь, что всё работает. Отрезок вывода должен получиться примерно таким:
```sh
Итерация №1 Игрок №1 карта: NINE CLUBS; игрок №2 карта: SEVEN HEARTS. 
Выиграл игрок 1! 
У игрока №1 19 карт, у игрока №2 17 карт
Итерация №2 Игрок №1 карта: JACK HEARTS; игрок №2 карта: ACE DIAMONDS. 
Выиграл игрок 2! 
У игрока №1 18 карт, у игрока №2 18 карт
Итерация №3 Игрок №1 карта: TEN HEARTS; игрок №2 карта: KING HEARTS. 
Выиграл игрок 2! 
У игрока №1 17 карт, у игрока №2 19 карт
Итерация №4 Игрок №1 карта: QUEEN CLUBS; игрок №2 карта: ACE HEARTS. 
Выиграл игрок 2! 
У игрока №1 16 карт, у игрока №2 20 карт
...
Итерация №1380 Игрок №1 карта: JACK DIAMONDS; игрок №2 карта: JACK SPADES. 
Спор - каждый остаётся при своих! 
У игрока №1 33 карт, у игрока №2 3 карт
Итерация №1381 Игрок №1 карта: JACK HEARTS; игрок №2 карта: TEN DIAMONDS. 
Выиграл игрок 1! 
У игрока №1 34 карт, у игрока №2 2 карт
Итерация №1382 Игрок №1 карта: SIX HEARTS; игрок №2 карта: ACE HEARTS. 
Выиграл игрок 1! 
У игрока №1 35 карт, у игрока №2 1 карт
Итерация №1383 Игрок №1 карта: QUEEN SPADES; игрок №2 карта: JACK SPADES. 
Выиграл игрок 1! 
У игрока №1 36 карт, у игрока №2 0 карт
Выиграл первый игрок! Количество произведённых итераций: 1383.
```

Если всё работает корректно - не забудьте закоммитить, запушить, отметить шаг как выполненный и - переходите к следующему шагу!
