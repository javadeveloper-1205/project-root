### Сборка проекта

На этом шаге мы упакуем код в один файл. Подключим к нашему проекту библиотеки, без которых не обходится ни один современный Java-проект:

   * _Slf4J_, чтобы иметь возможность писать логи. В качестве реализации возьмём Log4J
   * _Apache Commons Math_, чтобы использовать удобные методы для работы с массивами (например, `shaffle`)

Также мы настроим автоматический прогон тестов при сборке. Научимся обновлять используемые библиотеки и плагины. И, конечно, автоматизируем это, используя Make.

Как видим, предстоит выполнить много работы!

### Собираем приложение в JAR-файл

Когда проект состоит всего из одного пакета и одного класса, мы можем позволить себе просто "напрямую" компилировать и исполнять этот класс. Как мы это делали на первом шаге. Однако, когда пакетов и классов станет больше, делать так будет уже совсем неудобно.

Вы наверняка слышали, что в Java принято не только компилировать проект, но и собирать весь результат компиляции в один файл. Таким файлам принято давать расширение `jar` (сокращение от "**j**ava **ar**chive"). Это решает проблему **переноса** — вместо того, чтобы копировать кому-то десятки, а то и сотни файлов, из которых можно что-то забыть, вы копируете один. И остаётесь уверены при этом, что скопировали всю программу.

#### Собираем простой JAR

Для того, чтобы упаковать откомпилированный код в jar-файл (далее будем называть его "джарник"), поместив его в папку `./target/`, нужно выполнить следующую команду:

     $ jar cf ./target/{project-name}.jar -C ./target/classes .

Здесь `c` означает "создание" (create), `f` — "файл" (file).

Проверьте получившийся результат. Jar-архив — это обычный ZIP-архив, любой разархиватор его "возьмёт". Кроме того, текстовые оболочки командной строки, такие как Midnight Commander в *nix и MacOS и Far Manager в Windows, открывают их как обычные папки. Зайдите и посмотрите, что там внутри.

Действие, которое обычно предпринимают для создания итогового артефакта, называется у программистов `build`. Поэтому так и назовём команду в Makefile, которая это делает:
```makefile
build: compile
	jar cf ./target/{project-name}.jar -C ./target/classes .
```

Теперь проект можно запускать через jar-файл так:

     $ java -cp ./target/{project-name}.jar games.Slot

Из-за изменений в командах надо откорректировать Makefile:

* Сейчас мы запускаем код по-другому, поэтому измените команду `run`.
* Переименуйте команду по умолчанию в `build-run`. Замените в её зависимостях действие `compile` на `build`.

Проверьте, что после этих изменений команда по умолчанию `make` выдаёт прежний результат.

#### Собираем запусковый JAR

Jar-файл, созданный нами на предыдущем этапе, решал лишь задачу упаковки всех откомпилированных классов в один файл архива. Поэтому нам приходится при вызове указывать его как библиотеку, помещая в **classpath** при помощи ключа `-cp`.

Но было бы удобнее ещё и хранить в нём информацию о том, какой именно класс является запусковым (`entrypoint`). Чтобы любой пользователь не был вынужден вводить этот класс, а просто запускал джарник на выполнение.

Забегая немного вперёд, сразу покажем, как будет выглядеть вызов, когда мы сделаем наш jar запусковым:

     $ java -jar ./target/{project-name}.jar

Что же для этого нужно?

Если Вы исследовали структуру нашего джарника, то наверняка увидели, что, помимо каталога `games` c нашим откомпилированным классом, там содержится каталог со странным названием `META-INF`. В нём находится один файл под названием `MANIFEST.MF` следующего содержания:

     Manifest-Version: 1.0
     Created-By: 10.0.2 (Oracle Corporation)

Для того, чтобы сделать наш jar запусковым, нужно добавить в этот манифест одну строчку:

     Main-Class: games.Slot

Можно, конечно, сделать это при помощи разархиватора, редактора и архиватора, но есть более элегантный способ — указать утилите `jar` на entrypoint-класс.

Это делается при помощи дополнительного флага `e` (сокращение от "entrypoint") и указания после имени jar-файла полного имени entrypoint-класса. Модифицированная команда будет выглядеть так:

     $ jar cfe ./target/{project-name}.jar games.Slot -C ./target/classes .

У нас снова изменились команды, поэтому надо снова откорректировать Makefile: измените команды `build` и `run` (как показано выше). Запустите и убедитесь, что результат выдаётся корректно.

### Maven

В первом шаге мы добились компиляции и исполнения нашего кода. Сейчас мы научились собирать его в запусковый Jar-файл.

Однако на практике, в больших проектах, задача превращения исходных кодов в работающее приложение не столь проста. Помимо компиляции исходников и сборки их в jar требуется:

* проверять код линтерами на соответствие лучшим практикам и отсутствие ошибок
* выполнять копирование необходимых файлов, возможно, осуществив с ними некоторые преобразования
* найти и скопировать из интернета определённые библиотеки, необходимые для работы вашего кода. Ещё их называют **зависимостями** ("dependencies")
* генерировать определённые файлы, воспользовавшись какими-либо утилитами
* после компиляции запускать на исполнение тесты
* составлять отчёты с собранной в процессе сборки статистикой
* закачивать на сервер и разворачивать там приложение
* и другие задачи...

Все эти действия можно и дальше пытаться решить в рамках отдельных команд, скрываемых за элегантными алиасами утилиты Make. Но по мере роста сложности выполняемых операций, сложность скриптов Make будет расти линейно. В результате, рано или поздно, она станет неприемлемо высока для побочной задачи. И, как следствие, в командах разработчиков появляется отдельная роль — человека, который отвечает за сборку проекта. Он становится очень важным, поскольку без него мало кто знает, как собрать проект. Потом, по мере усложнения проекта, ему становятся нужны помощники — и заказчик вынужден идти на встречу, платя за найм новых людей... Так это и было в 2000-х — ваш покорный слуга это наблюдал, работая в Luxoft`е в 2006-2007 на Deuche Bank.

Но, в отличие от специфики бизнес-проблем, решаемых проектами, эти проблемы оказались общими для большинства проектов на Java. И поэтому нашлись люди, которые сумели решить их в общем виде — так, чтобы сложность инструментария сборки от сложности проекта росла не линейно, а примерно логарифмически — то есть гораздо менее быстро. Такой тип решений получил название **build-tool**.

В качестве build-tool мы возьмём **Maven**, так как он проще. Да и в Java-мире Maven более распространён, чем его конкуренты. Поэтому он лучше всего подходит для нашего проекта.

Если Maven у вас не установлен, его необходимо установить. Проверить, установлен он или нет, можно командой:

     $ mvn -v

Если она выдаёт текст наподобие `Apache Maven 3.5.4...`, то всё в порядке. Иначе посмотрите инструкцию установки Maven для вашей ОС.

### Версионность Maven

Если Maven на вашем компьютере обновится, то есть риск, что настройки вашего проекта могут войти в конфликт с более новой версией Maven. Эта проблема решается установкой в проект так называемого **Wrapper** — локальной для проекта копии Maven. С помощью такого решения те, у кого не установлен Maven нужной версии (или вообще никакой), также могут собрать ваш проект.

Поэтому хорошей практикой при использовании build-tool является фиксация его версии для данного проекта. Это даёт разработчикам уверенность в том, что проект обязательно соберётся в системе пользователя, как бы он не "накосячил" (забыв установить build-tool или установив его не той версии). На практике это очень удобно.

Для этого выполните в корне проекта команду:

     $ mvn -N io.takari:maven:wrapper -Dmaven=3.6.0

В результате в директории проекта появятся следующие файлы:

* каталог `.mvn`, содержащий подкаталог `wrapper`, в котором находятся файлы:
  * `maven-wrapper.properties` — файл, содержащий настройки. В частности, адрес, по которому можно скачать...
  * `maven-wrapper.jar` — собственно, рабочий дистрибутив maven нужной версии. Этот файл необязательно хранить в удалённом гит-репозитории, так как при наличии предыдущего файла скрипт `mvnw` скачает его. Так что его можно смело внести в `.gitignore`

* файлы `mvnw` и `mvnw.cmd`. Они содержат абсолютно аналогичные сценарии, которые выполняют команды Maven, используя wrapper из папки `./.mvn/wrapper/`. А если его не находят, а находят лишь файл `maven-wrapper.properties` — скачивают wrapper и выполняют команды.

Когда выполняете команду `mvn`, то запускаете maven, установленный глобально в вашей операционной системе. Если же вы выполните в корне проекта команду `./mvnw`, то запустите `wrapper` — локальную версию maven для вашего проекта. Чтобы избежать всевозможные проблемы совместимости, при выполнении команд надо пользоваться "родной" версией maven. Поэтому все maven-команды в вашем проекте надо запускать через `./mvnw`.

### Project Object Model (POM)

Maven конфигурируется при помощи файла `pom.xml`, который должен располагаться в корне проекта.

В качестве образца возьмём [файл](https://github.com/hexlet-boilerplates/java-package/blob/master/pom.xml) из [boilerplate-проекта "java-package"](https://github.com/hexlet-boilerplates/java-package). Скопируйте его в корень проекта.

Давайте последоватльно проанализируем этот конфигурационный файл:

* `Шапка` и значение тега `modelVersion`— стандартные и никогда не меняются.

* В теге `groupId` содержится **глобальный идентификатор** для всех ваших проектов.
  Формируется этот иденитификатор так: обычно берётся имя сайта и меняются местами домены первого и второго уровней. Например, для hexlet.io groupId стоило бы назвать `io.hexlet`. Иногда потом ставится дополнительная точка и добавляется ещё раздел. Так, например, у Apache Foundation - там много проектов, поэтому прописывается `org.apache.commons`, а не просто `org.apache`. Если у вас нет сайта, лучше всего прописать ваше имя с фамилией через точку, например, `Petr.Ivanov`.

* В теге `artifactId` прописывается **название проекта**. Чтобы не создавать путаницу, рекомендуется, чтобы название проекта совпадало с названием корневого каталога проекта.

* в теге `version` оставьте пока значение `1.0-SNAPSHOT` — это означает, что о версионной политике своего проекта вы ещё не думали и версии по факту нет.

#### Cекция свойств ("Properties")

В этой секции объявляются константы, значения которых могут использоваться по всему POM-файлу (в том числе и в самой этой секции) при помощи синтаксиса `${имя-константы}`.

Первые две константы — стандартные свойства для указания кодировки:

- **project.build.sourceEncoding** — кодировка файлов с исходным кодом в проекте.

- **project.reporting.outputEncoding** — кодировка, в которой различные плагины Maven будут писать отчёты о своей роли в сборке проекта.

Следующие три константы определяют версию Java на проекте:

- **maven.compiler.release**. На момент начала проекта последняя актуальная версия — 12-я. Поэтому поставьте её.

В примерах этой секции мы видим, как заданные свойства использовать — нужно обрамлять их фигурными скобками и впереди ставить знак `$`.

Дальше описываются константы, обозначающие версии внешних библиотек.

Последними описываются константы — версии плагинов.

#### Секция зависимостей ("Dependencies")

Зависимости добавляются в теге `dependencies`.

Каждая зависимость выкачивается Maven\'ом с сайта Maven Central (есть [прямой интерфейс доступа к нему из браузера](http://search.maven.org)).

Зависимости имеют довольно громоздкий вид. Рассмотрим первую из указанных зависимостей:
```xml
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>{версия.библиотеки}</version>
    <optional>true</optional>
    <scope>compile</scope>
</dependency>
```

* `version` здесь указано, какую использовать версию внешней библиотеки. Обычно лучше выбирать самую последнюю на момент разработки
  - Все версии всех библиотек можно посмотреть на сайте [Maven Central](https://search.maven.org/) (есть и другие Maven-репозитории, но этот — самый популярный).
  - В качестве версии Maven позволяет указать значения `LATEST` и `RELEASE` (хотя и ругается WARNING'ами на это при сборке), которые означают, соответственно, _последнюю_ и _последнюю стабильную_ версию на текущий момент. Но использование этой возможности является плохой практикой, поскольку версия тогда будет обновляться автоматически, и вы даже не будете об этом знать. Если это станет причиной ошибки, то Вы далеко не сразу сообразите, что дело в этом. "Я, вроде, ничего особенного не сделал, а оно вдруг поломалось!.."
  - Не думайте, что все версии всех используемых библиотек и модулей вам придётся обновлять вручную — в Maven есть автоматические средства для этого, с которыми мы познакомимся чуть позже.
     + правда, чтобы этот функционал работал, версию библиотеки нужно обязательно выносить в свойство (в секцию property).
* `optional` — необязательный элемент. Нужен для того, чтобы не тянуть эту зависимость за собой в тот проект, в котором данный проект будет выступать в качестве внешней библиотеки.

* `scope` — также необязателен. Значение по умолчанию — `compile`, так что в данном случае его можно не указывать. В качестве альтернатив могут использоваться значения:
  - `provided` — будет означать, что данная библиотека будет присутствовать в момент компиляции, но в итоговый артефакт (в нашем случае — JAR-файл) не войдёт.
  - `test` — будет означать, что библиотека будет использоваться для запуска тестов, но в итоговый артефакт также не попадёт.

Далее нам в проекте (на 4-м шаге) понадобится библиотека `Apache Commons Math`. Добавьте её к остальным зависимостям нашего проекта. Подсказка:
* её `groupId` — `org.apache.commons`
* `artifactId` — `commons-math3`
* последнюю версию вы найдёте на [сайте Maven Central](https://search.maven.org/)

Также на 7-м шаге понадобится библиотека `Log4J` - она уже есть в зависимостях проекта. Все остальные зависимости следует убрать - в данном проекте они нам не понадобятся. Когда сделаете это, не забудьте убрать и свойства (properties), которые были заведены для указания их версий.

### Плагины

По сути всё, что делает Maven — координирует работу плагинов. Так что за всё, что делает Maven, отвечает какой-то плагин. Сложность зачастую заключается в том, чтобы разобраться — какой именно плагин.

#### Super-POM или "Convention Over Configuration" по-Maven\`овски

Maven разрабатывался по уже упомянутому принципу "Convention Over Configuration", поэтому в него по умолчанию уже включено некоторое количество плагинов, которые могут выполнять массу задач.

Например, по умолчанию включён плагин **maven-compiler-plugin**, который осуществляет компиляцию. Ему только нужно дать понять, какая версия Java у нас на проекте. Что мы и сделали ранее, указав именно для этого плагина свойство **maven.compiler.release**. Если бы мы не укзали версию, то активизировалось бы заложенное в плагин поведение по умолчанию, которое вступило бы в силу при компиляции. Оно соответствует безнадёжно-устаревшей к сегодняшнему дню 6-ой версии Java.

Реализуется этот принцип следующим образом: у Maven есть так называемый "Super-POM". Это файл `pom.xml`, в Maven он лежит в архиве `{папка-установки-Maven'а}/lib/maven-model-builder-3.6.0.jar` по пути `org/apache/maven/model/pom-4.0.0.xml`. Тот `pom.xml`, который пишете для своего проекта Вы, накладывается на super-POM. Любые конфликты (противоречия, когда в вашем pom-файле указано одно значение для свойства, а в super-pom-файле — другое) разрешаются в пользу вашего pom-файла. Но, если вы чего-то важного просто не укажете — не беспокойтесь, вам "прилетит" значение из super-pom-файла. В результате такой "операции сложения" формируется так называемый "эффективный POM" ("effective-pom").

Выполните следующую команду, чтобы увидеть результат этой операции "эффективный POM":

     $ mvn help:effective-pom

Попробуйте внести изменения в pom-файл проекта и повторить команду, отследив изменения.

### Собираем Jar при помощи Maven

Для выполнения действий, аналогичных тем, что мы уже выполняли ранее, нам пока будут нужны 2 команды:
* `package` — собрать наш проект в `*.jar`-файл, который потом можно будет стартовать. В результате файл будет находиться в каталоге `target` и называться `{имя-проекта}-{версия}-jar-with-dependencies.jar`. Его можно будет вызывать при помощи команды `java -jar {имя-jar-файла}`. В качестве версии пока лучше оставить значение `1.0-SNAPSHOT`

* `clean` — очистить каталог `target` перед новой сборкой, чтобы резульаты предыдущей сборки никак не повлияли на следующую

Команды можно выполнять подряд, перечисляя их в командной строке друг за другом:

     ./mvnw clean package

Плагины указываются в тегах `build` и `plugins`.

Плагин для упаковки проекта в джарник называется `maven-assembly-plugin`.

_Кого-то может сбить с толку этот факт, поскольку есть ещё и `maven-jar-plugin`. И, судя по названию, да и по тому, что он присутствует в super-POM (то есть неявно присутствует в проекте), может показаться, что он для этого подходит лучше. Однако это не так — данный плагин не включает зависимые библиотеки, а лишь компилирует и упаковывает в JAR-файл сам код проекта. В хоть сколько-нибудь боевом проекте это бесполезно. Плагин `maven-assembly-plugin`, напротив, позволяет включить все зависимости в итоговый JAR, поэтому мы будем использовать его._

Плагины прописываются здесь:
```xml
<build>
    <plugins>
        <!-- сюда помещаем описание плагинов -->
    </plugins>
</build>
```

Описание плагина `maven-assembly-plugin` можно так же взять из [файла](https://github.com/hexlet-boilerplates/java-package/blob/master/pom.xml). Менять в его описании имеет смысл лишь параметр, отвечающий за _entrypoint_. Вот как он выглядит:
```xml
<manifest>
    <mainClass>{имя.вашего.main-class\`а.вместе.с.пакетом}</mainClass>
</manifest>
```

Поменяйте содержимое тега `mainClass`, вписав туда класс `games.Slot` в соответствии с тем, что мы делали ранее без Maven.

Теперь запустите на исполнение:

     $ ./mvnw clean package

В ответ будет "многа букавак" (отчёт о том, как происходит сборка), но примерно в конце должна быть надпись "BUILD SUCCESSFUL". Это значит, что всё получилось успешно и проект собран.

Если вместо этой надписи вы увидели надпись "BUILD FAILED" — значит, чуть выше должно быть сообщение о возникшей в ходе сборке ошибке. С ним нужно разобраться и повторить процедуру сборки.

Результатом сборки должен быть файл "./target/{имя-вашего-проекта}-1.0-SNAPSHOT-jar-with-dependencies.jar" (в каталоге `target`).

Запустите его и убедитесь, что код отрабатывает корректно.

Обновите `Makefile`, прописав вместо старых, нативных, реализации при помощи Maven.

При этом от действия `compile` можно уже отказаться — оставьте только `build`.

### Обновляем версии библиотек и плагинов

У Maven есть плагин `versions-maven-plugin`, при помощи которого можно обновлять версии библиотек и плагинов.

Для того, чтобы обновлять версии, они должны быть вынесены в константные свойства (properties).

Версии библиотек обновляются командой:

     $ ./mvnw versions:update-properties

а версии плагинов:

     $ ./mvnw versions:display-plugin-updates

При этом старые версии, чтобы на них можно было вернуться в случае проблем, сохраняются в файле `pom.xml.versionsBackup`, так что во избежание проблем, рекомендуется его так же за-gitignore\'ить.

Укажите в зависимости `commons-math3` предыдущую версию — `3.6` — и обновите её при помощи соответствующей команды плагина `versions`

Добавьте команду `update` в Makefile, которая бы обновляла плагины и зависимости.

Закоммитьте и запуште в GitHub то, что сделали. Отметьте, что ваш код готов к проверке, и переходите к следующему шагу! :)
