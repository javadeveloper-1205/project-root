# Шаг №6 - Третья игра - "Очко"

## Для чего выполнять это задание

Задание спроектировано для Вашей тренировки в процедурном программировании c одним существенным изменением - в задании предполагается работа с пользователем, т.е. "интерактивность".

Те из Вас, кто считает, что владеет программированием в ООП и функциональном стиле, потерпите и постарайтесь себя сдерживать - задание достаточно простое, чтобы можно было обойтись без этого и решить задачу, сосредоточившись исключительно на операторах, статических (`static`) методах, статических полях и примитивных типах c простыми `enum`'ами.

Как уже говорилось, ООП у нас начнётся со следующего проекта, а функциональный подход будет возможность попрактиковать, начиная с третьего проекта.

## Что должно получиться

Нужно написать [карточную игру "Очко" ("Black Jack")](https://ru.wikipedia.org/wiki/Очко_(игра)) колодой из 36 карт. 

## Как выполнять задание

Следующая игра - очко - предполагает интерактивность, т.е. взаимодействие с пользователем в процессе игры. В связи с этим, нам нужно будет модифицировать процедуру ввода данных со стороны пользователя, которая у нас была на предыдущем шаге и использовалась для выбора игры. Дело в том, что то, в каком виде она у нас сейчас - работает лишь один раз - до этого нас это устраивало, но сейчас нам понадобится обращаться к пользователю многократно.

Кроме того, функционал, связанный со спецификой карточных игр, мы можем переиспользовать, поэтому лучше его вынести в отдельный класс.

Но для начала...

### Создаём заглушку и определяем третий вариант для выбора

В классе `Choice` нужно добавить игру "Очко".

### Модифицируем процедуру ввода данных

Итак, в чём проблема с нашим обычным вводом? Напомним, речь о вот этом коде:
```java
switch (System.in.read()) {
    case '1': Slot.main(); break;
    case '2': Drunkard.main(); break;
    default: System.out.println("Игры с таким номером нет!");
}
```

Всё дело в том, что если вы выполните его второй раз, то он не спросит пользователя уже ни о чём, а сработает так, будто пользователь ввёл код символа перевода строки. Дело здесь вот в чём: когда пользователь вводил символ, он после этого нажимал клавишу ENTER и это приводило к двум вещам:
   * метод `read` понимал, что пользователь уже ввёл всё, что хотел, и теперь то, что он ввёл, надо вернуть в программе
   * в т.н. буфер ввода попадал не только символ, введённый пользователем, но и символ перевода строки. Именно из этого буфера потом будут вычитываться новые символы, когда мы их снова запросим вызовом `System.in.read()` - вот и получается, что, запросив символ второй раз, `read` вернёт нам следующий символ из буфера - символ перевода строки, и лишь на третий раз, увидев, что буфер пуст, спросит об очередном вводе пользователя.

Усугубляется всё ещё и тем, что в различных операционных системах различные символы или последовательности символов отвечают за перенос строки, так что в общем случае мы даже не можем сказать Java`е - "прочти из пользовательского ввода 2 символа и дай нам первый из них!", поскольку в какой-то операционной системе их может оказаться и 3, а нам нужно чётко сказать, сколько символов считывать.

Так что же делать?

Во-первых, давайте в общем виде выясним последовательность символов, которые в данной операционной системе обозначают символ перевода строки и запишем это значение в константу. Делается это из Java'ы запросом системного свойства примерно так:
```java
static final String LINE_SEPARATOR = System.lineSeparator();
```

Теперь давайте напишем метод, который будет делать то, что нам нужно - считывать, что ввёл пользователь, рассчитывая, что он ввёл один символ и нажал ENTER, после чего возвращать этот символ, оставляя при этом буфер ввода пустым, чтобы в следующий раз ввод был также считан корректно. Для этого нам понадобится переопределённый (override) вариант метода `read`, который принимает массив байт и наполняет его:
```java
static char getCharacterFromUser() throws IOException {
    byte[] input = new byte[1 + LINE_SEPARATOR.length()];
    if (System.in.read(input) != input.length)
        throw new RuntimeException("Пользователь ввёл недостаточное кол-во символов");
    return (char) input[0];
}
```

Замените в классе `Choice` вызов `System.in.read()` на вызов данного метода.

### Выносим функционал, связанный с картами

В предыдущей игре (шаг 5) мы уже использовали карты и для этой игры нам они снова будут нужны. Так что для удобства давайте создадим отдельный класс `CardUtils` и перенесём в него два enum'а (масть - `Suit` и достоинство - `Par`), статические методы:  
   * `getSuite`  
   * `getPar`  
   * `toString`  
   
и константы:  
   * `PARS_TOTAL_COUNT`  
   * `CARDS_TOTAL_COUNT`  

Обращение к этим методам теперь будет происходить из внешних классов, поэтому нужно будет использовать точечную нотацию, т.е. чтобы вызвать метод `getSuite` с аргументом 28 нам теперь нужно будет писать вместо:  
```java
getSuite(28);
```

следующее:
```java
CardUtils.getSuite(28);
```

Кроме того необходимо вынести функционал получения перемешанной колоды карт, определив эту операцию в отдельном методе:
```java
static int[] getShaffledCards() {
    // колода подряд
    int[] cards = {
            0, 1, 2, 3, 4, 5, 6, 7, 8,  // бубны
            9, 10, 11, 12, 13, 14, 15, 16, 17,  // червы
            18, 19, 20, 21, 22, 23, 24, 25, 26,  // трефы
            27, 28, 29, 30, 31, 32, 33, 34, 35}; // пики

    MathArrays.shuffle(cards);
    return cards;
}
```

Уберите этот код из метода `main` класса `Drunkard` и замените на вызов данного метода. 

Для всего этого можно указать пакетную область видимости, а можно и `public` - принципиально, чтобы не `private`.

### Структуры данных

#### Определяем правила подсчёта размерности

Теперь давайте поговориим о специфике работы с данными в рамках игры "очко". Итак, в этой игре прежде всего принято иначе интерпретировать размерность карт по очкам. Например, валет здесь заменяет собой 2-ку, дама - 3-ку, а король - 4-ку и только туз интерпретируется как 11. Попробуйте описать это в рамках метода класса BlackJack, должно получиться что-то вроде такого:  
```java
private static int value(int card) {
    switch (CardUtils.getPar(card)) {
        case JACK: return 2;
        case QUEEN: return 3;
        case KING: return 4;
        case SIX: return 6;
        case SEVEN: return 7;
        case EIGHT: return 8;
        case NINE: return 9;
        case TEN: return 10;
        case ACE:
        default: return 11;
    }
}
```

`default` придётся указать, потому что этого требует компилятор - он может быть любым, потому что других карт всё равно пока нет и мы перечислили все.

#### Работа с массивами карт

Раздача карт в каждом раунде игры будет осуществляться заново. Так что, в отличие от прошлого шага, здесь у нас наблюдается более простая работа со стопками карт - принцип FIFO нам здесь не нужен, нужны только одинарные счётчики по каждому из массивов.

Правда, массивов теперь у нас будет 3 - колода карт, из которой игроки берут карты в свои стопки и, собственно, эти стопки - у каждого из двоих игроков своя, всего получается 3:
```java
private static int[] cards; // Основная колода
private static int cursor; // Счётчик карт основной колоды
     
private static int[][] playersCards; // карты игроков. Первый индекс - номер игрока
private static int[] playersCursors; // курсоры карт игроков. Индекс - номер игрока
```

Теперь насчёт инициализации. Т.к. эта игра у нас разбита на в общем-то независимые раунды (связаны они будут только деньгами, которые необходимы для накопления выигрыша), в которых каждый раз заново будет происходить раздача карт, то и инициализацию полей имеет смысл вынести в отдельный метод, чтобы вызывать его при старте каждого раунда игры. Только деньги имеет смысл инициализировать при объявлении:
```java
private static int[] playersMoney = {100, 100};
     
private static void initRound() {
    System.out.println("\nУ Вас " + playersMoney[0] + "$, у компьютера - " + playersMoney[1] + "$. Начинаем новый раунд!");
    cards = CardUtils.getShaffledCards();
    playersCards = new int[2][MAX_CARDS_COUNT];
    playersCursors = new int[]{0, 0};
    cursor = 0;
}
```

_Не беспокойтесь, константу MAX_CARDS_COUNT мы определим чуть ниже_

По поводу размеров. У колоды размер, конечно, `CARDS_TOTAL_COUNT`, а какой нужно заложить максимальный размер стопкам карт, соответствующим игрокам? В общем-то мы должны понимать, что по условиям игры, кол-во карт с суммарным кол-вом очков больше 21`го брать не нужно. Так что давайте посчитаем, сколько для 21-го максимально может понадобиться карт?  
   * 4 валета (каждый по `2`) = `8`  
   * 4 дамы (каждая по `3`) = `12`  

Вот и всё, в сумме у нас уже получается `20`, больше не втиснешь даже валета (даже если бы в колоде мог найтись 5-й валет) - будет уже перебор, больше `21`'го. Так что разумно будет исходить из того, что максимальное кол-во карт, которые может взять один игрок = `8`.

Запишем это значение в константу и заодно определим константу со значением 21 для последующих проверок:
```java
private static final int MAX_VALUE = 21;
private static final int MAX_CARDS_COUNT = 8;
```

##### Берём карту из колоды

Реализуйте метод, извлекающий следующую карту из колоды и помещающий её в стопку карт указанного игрока. Он может иметь следующую сигнатуру:
```java
private static int addCard2Player(int player) {
    // todo: реализуйте!
}
```

Помните, что по итогу карта не только должна оказаться в стопке карт указанного игрока, но и должны быть сдвинуты курсоры как у игрока, так и у колоды карт, чтобы ни одному игроку не досталась карта, которая уже досталась другому.

##### Суммируем очки игрока

Теперь реализуйте метод, который будет суммировать очки игрока. Он может иметь следующую сигнатуру:
```java
static int sum(int player) {
    // todo: реализуйте!
}
```

Помните, что оббегать нужно не весь массив карт игрока, а лишь до значения его счётчика, при чём не включая элемент с номером счётчика.

Также сделайте метод, который вызывал бы метод `sum` и возвращал бы кол-во очков только если оно не превышает максимального значения - `21`, в ином случае возвращал бы `0`: 
```java
static int getFinalSum(int player) {
    // todo: реализуйте!
}
```

_Если Вам кажется, что можно слить два этих метода в один - попробуйте, но тогда будет сложнее делать проверки в основном коде игры._

### Вопрос пользователю

Мы уже частично обсудили выше проблемы, связанные с вводом-выводом с консоли, так что давайте напишем метод, который будет использовать этот функционал для того, чтобы задать вопрос пользователю и, получив подтверждение в виде символа `Y`(либо его маленького варианта `y`) возвращать `true`, во всех же остальных случаях - `false`:
```java
static boolean confirm(String message) throws IOException {
    System.out.println(message + " \"Y\" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)");
    switch (getCharacterFromUser()) {
        case 'Y':
        case 'y': return true;
        default: return false;
    }
}
```

### Реализуем логику игры

Теперь, когда мы создали себе весь необходимый инструментарий, будет относительно-легко реализовать игру. Логика у неё следующая:  
   * Вначале мы определяем цикл, выходное условие которого - у кого-то из игроков закончились деньги.
   * После этого цикла можно прописать простой финальный блок - и на этом закончить программу:
      ```java
     if (playersMoney[0] > 0)
         System.out.println("Вы выиграли! Поздравляем!");
     else
         System.out.println("Вы проиграли. Соболезнуем...");
      ```

   * Внутри же цикла мы инициализируем раунд вызовом метода `initRound`
   * После этого даём игроку две карты
   * Если сумма его очков меньше, чем 20 (взяли бы 21, но минимальная гранулярность у нас 2, поскольку размерности больше, чем у валета у нас не предусмотрено, а значит, если у игрока 20 очков - не имеет смысла брать ещё карту) предлагаем ему взять ещё. Соглашается - берём ещё и снова на проверку. Этот шаг может повторяться теоретически бесконечно, но на практике не более 5-ти раз (ситуацию мы разобрали выше, где определили максимальное количество карт, которые можно взять).  
   * Считаем финальную сумму по игроку.
   * Затем тоже самое проделываем с компьютером.  
      * Тут с одной стороны проще - можно не спрашивать никого, с другой - нужно принимать решение - когда брать карту, а когда не брать. Эксперты говорят, что нужно ориентироваться на 16 или на 17 очков, если тебе выпало столько, то дальше брать карту рисковано - заложите одно из этих чисел в момент принятия решения вашим компьютерным игроком.  
   * Печатаем сумму очков игрока и компьютера _реальную, т.е. с учётом перескока через 21'о - тут необходимо уже пользоваться методом `getFinalSum`, а не `sum`_
   * Тому игроку, у кого очков больше, перекидываем 10$ от игрока, у которого сумма очков меньше.
   * Если у игроков одинаковые суммы очков - все остаются при своих.  

Вывод игры может быть примерно такой:
```sh
У Вас 100$, у компьютера - 100$. Начинаем новый раунд!
     
Вам выпала карта JACK CLUBS
Вам выпала карта TEN DIAMONDS
Берём ещё? "Y" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)
y
Вам выпала карта EIGHT CLUBS
Компьютеру выпала карта JACK SPADES
Компьютеру выпала карта SIX DIAMONDS
Компьютер решил взять ещё и ему выпала карта KING DIAMONDS
Компьютер решил взять ещё и ему выпала карта NINE DIAMONDS
Сумма ваших очков - 20, компьютера - 21
Вы проиграли раунд! Теряете 10$

У Вас 90$, у компьютера - 110$. Начинаем новый раунд!

Вам выпала карта JACK HEARTS
Вам выпала карта SEVEN SPADES
Берём ещё? "Y" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)
y
Вам выпала карта SIX CLUBS
Берём ещё? "Y" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)
y
Вам выпала карта EIGHT CLUBS
Компьютеру выпала карта SEVEN DIAMONDS
Компьютеру выпала карта ACE DIAMONDS
Сумма ваших очков - 0, компьютера - 18
Вы проиграли раунд! Теряете 10$

У Вас 80$, у компьютера - 120$. Начинаем новый раунд!

Вам выпала карта SIX SPADES
Вам выпала карта JACK CLUBS
Берём ещё? "Y" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)
y
Вам выпала карта TEN CLUBS
Берём ещё? "Y" - Да, {любой другой символ} - нет (Чтобы выйти из игры, нажмите Ctrl + C)
n
Компьютеру выпала карта EIGHT DIAMONDS
Компьютеру выпала карта SEVEN CLUBS
Компьютер решил взять ещё и ему выпала карта JACK HEARTS
Сумма ваших очков - 18, компьютера - 17
Вы выиграли раунд! Получаете 10$

У Вас 90$, у компьютера - 110$. Начинаем новый раунд!
...
```

Если всё работает корректно - не забудьте закоммитить, запушить, отметить шаг как выполненный и - переходите к следующему, заключительному шагу!
